/* This is an automatically-generated file. Do not edit! */
"/*\n"
" * Copyright (C) 2016,2017,2019,2020 Edd Biddulph\n"
" *\n"
" * This program is free software; you can redistribute it and/or modify\n"
" * it under the terms of the GNU General Public License as published by\n"
" * the Free Software Foundation; either version 2 of the License, or (at\n"
" * your option) any later version.\n"
" *\n"
" * This program is distributed in the hope that it will be useful, but\n"
" * WITHOUT ANY WARRANTY; without even the implied warranty of\n"
" * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
" *\n"
" * See the GNU General Public License for more details.\n"
" *\n"
" * You should have received a copy of the GNU General Public License\n"
" * along with this program; if not, write to the Free Software\n"
" * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n"
" * USA.\n"
" *\n"
" * =======================================================================\n"
" *\n"
" * GPU-based pathtracing - Ray intersection and shading.\n"
" *\n"
" * =======================================================================\n"
" */\n"
" \n"
"#ifndef NUM_BOUNCES\n"
"# define NUM_BOUNCES 0\n"
"#endif\n"
"\n"
"#ifndef NUM_SHADOW_SAMPLES\n"
"# define NUM_SHADOW_SAMPLES 1\n"
"#endif\n"
"\n"
"#ifndef NUM_LIGHT_SAMPLES\n"
"# define NUM_LIGHT_SAMPLES 1\n"
"#endif\n"
"	\n"
"#ifndef NUM_SKY_SAMPLES\n"
"# define NUM_SKY_SAMPLES 1\n"
"#endif\n"
"\n"
"#ifndef NUM_AO_SAMPLES\n"
"# define NUM_AO_SAMPLES 0\n"
"#endif\n"
"\n"
"#ifndef TRI_SHADOWS_ENABLE\n"
"# define TRI_SHADOWS_ENABLE 1\n"
"#endif\n"
"\n"
"#ifndef DIFFUSE_MAP_ENABLE\n"
"# define DIFFUSE_MAP_ENABLE 1\n"
"#endif\n"
"\n"
"#ifndef RAND_TEX_LAYERS\n"
"# define RAND_TEX_LAYERS 1\n"
"#endif\n"
"\n"
"#ifndef BLUENOISE_TEX_WIDTH\n"
"# define BLUENOISE_TEX_WIDTH 64\n"
"#endif\n"
"\n"
"#ifndef BLUENOISE_TEX_HEIGHT\n"
"# define BLUENOISE_TEX_HEIGHT 64\n"
"#endif\n"
"\n"
"#ifndef TAA_ENABLE\n"
"# define TAA_ENABLE 0\n"
"#endif\n"
"\n"
"#ifndef BUMP_ENABLE\n"
"# define BUMP_ENABLE 1\n"
"#endif\n"
"\n"
"#define EPS		(1.0 / 32.0)\n"
"#define MAXT	2048.0\n"
"#define PI		acos(-1.0)\n"
"\n"
"// Diffuse (albedo) texture map.\n"
"uniform sampler2D diffuse_texture;\n"
"\n"
"// BSP tree data.\n"
"uniform sampler2D		bsp_planes;\n"
"uniform sampler2D 	bsp_branches;\n"
"uniform isampler2D	bsp_lightrefs;\n"
"\n"
"// Triangle mesh data.\n"
"uniform isamplerBuffer 	tri_nodes0;\n"
"uniform isamplerBuffer 	tri_nodes1;\n"
"uniform samplerBuffer 	tri_vertices;\n"
"uniform isamplerBuffer 	triangles;\n"
"\n"
"#if TAA_ENABLE\n"
"// Triangle mesh data from the previous frame.\n"
"uniform isamplerBuffer 	tri_nodes0_prev;\n"
"uniform isamplerBuffer 	tri_nodes1_prev;\n"
"uniform samplerBuffer 	tri_vertices_prev;\n"
"uniform isamplerBuffer 	triangles_prev;\n"
"#endif\n"
"\n"
"// Lightsource data.\n"
"uniform samplerBuffer 	lights;\n"
"uniform isamplerBuffer 	lightrefs;\n"
"\n"
"// PRNG table.\n"
"uniform sampler1D randtex;\n"
"uniform sampler2DArray bluenoise;\n"
"\n"
"// TAA feedback textures and transformations.\n"
"uniform sampler2D taa_world;\n"
"uniform mat4 current_world_matrix = mat4(1);\n"
"uniform mat4 previous_world_matrix = mat4(1);\n"
"uniform vec3 previous_view_origin = vec3(0);\n"
"\n"
"// Uniform attributes.\n"
"uniform int		frame = 0;\n"
"uniform float	ao_radius = 150.0;\n"
"uniform vec3	ao_color = vec3(1);\n"
"uniform float	bounce_factor = 0.75;\n"
"uniform float	exposure = 1.5;\n"
"uniform float	gamma = 2.2;\n"
"uniform float	bump_factor = 0.045;\n"
"uniform int		rand_tex_layer = 0;\n"
"\n"
"// node offset for restricting the way in which shadows are received from triangle meshes.\n"
"uniform int shadow_ray_node_offset = 0;\n"
"\n"
"// Inputs from the vertex stage.\n"
"in vec4 texcoords[8], color;\n"
"\n"
"// Globals.\n"
"vec4 out_pln;\n"
"vec3 bluenoise_sample;\n"
"\n"
"// Produces a pair of random numbers.\n"
"vec2 rand(int index)\n"
"{\n"
"	return fract(texelFetch(randtex, index, 0).rg + bluenoise_sample.rg);\n"
"}\n"
"\n"
"// Returns the interval along the given ray which intersects an axis-aligned cuboid of the given size centered at the origin.\n"
"vec2 boxInterval(vec3 ro, vec3 rd, vec3 size)\n"
"{\n"
"	vec3 mins = (size * -sign(rd) - ro) / rd;\n"
"	vec3 maxs = (size * +sign(rd) - ro) / rd;	\n"
"	return vec2(max(max(mins.x, mins.y), mins.z), min(min(maxs.x, maxs.y), maxs.z));\n"
"}\n"
"\n"
"// Returns false if the given ray intersects any triangle mesh in the scene and the distance\n"
"// to the intersection along the ray is less than maxdist, otherwise returns true.\n"
"bool traceRayShadowTri(vec3 ro, vec3 rd, float maxdist,\n"
"	isamplerBuffer nodes0, isamplerBuffer nodes1, samplerBuffer vertices, isamplerBuffer tris, int node_offset)\n"
"{\n"
"#if TRI_SHADOWS_ENABLE\n"
"	// Start at the root node, or an offset node index.\n"
"	int node = node_offset;\n"
"\n"
"	do\n"
"	{\n"
"		ivec4 n0 = texelFetch(nodes0, node);\n"
"		ivec4 n1 = texelFetch(nodes1, node);\n"
"\n"
"		// Test for intersection with the bounding box.\n"
"		vec2 i = boxInterval(ro - intBitsToFloat(n1.xyz), rd, intBitsToFloat(n0.xyz));\n"
"\n"
"		if (i.x < i.y && i.x < maxdist && i.y > 0.0)\n"
"		{\n"
"			// The ray does intersect this node, so don't skip it.\n"
"\n"
"			if (n1.w != -1)\n"
"			{\n"
"				// The node is a leaf node, so test for intersection with the referenced triangle.\n"
"				ivec2 tri = texelFetch(tris, n1.w).xy;\n"
"\n"
"				vec3 p0 = texelFetch(vertices, tri.x & 0xffff).xyz;\n"
"				vec3 p1 = texelFetch(vertices, tri.x >> 16).xyz;\n"
"				vec3 p2 = texelFetch(vertices, tri.y & 0xffff).xyz;\n"
"\n"
"				// Plane intersection.\n"
"				vec3 n = cross(p1 - p0, p2 - p0);\n"
"				float t = dot(p0 - ro, n) / dot(rd, n);\n"
"\n"
"				// Signed areas of subtriangles.\n"
"				float d0 = dot(rd, cross(p0 - ro, p1 - ro));\n"
"				float d1 = dot(rd, cross(p1 - ro, p2 - ro));\n"
"				float d2 = dot(rd, cross(p2 - ro, p0 - ro));\n"
"\n"
"				// The ray intersects the triangle only if the subtriangles all have the same sign and\n"
"				// the ray intersects the triangle's plane.\n"
"				if (sign(d0) == sign(d1) && sign(d0) == sign(d2) && t < maxdist && t > 0.0)\n"
"					return false;\n"
"			}\n"
"			\n"
"			// Step to the immediate next node.\n"
"			++node;\n"
"		}\n"
"		else\n"
"		{\n"
"			// The ray does not intersect this node, so skip over all the nodes contained within it.\n"
"			node = n0.w;\n"
"		}\n"
"		\n"
"	} while (node > 0);\n"
"#endif\n"
"\n"
"	// There is no intersection detected.\n"
"	return true;\n"
"}\n"
"\n"
"// Returns the closest distance along the given ray at which the ray intersects a solid leaf in the\n"
"// BSP, or returns MAXT if there was no intersection.\n"
"float traceRayBSP(vec3 org, vec3 dir, float t0, float max_t)\n"
"{\n"
"	// The 'other' variables represent a one-level stack.\n"
"	vec2 other_node = vec2(0);\n"
"	float other_t1 = max_t;\n"
"	vec4 other_pln0;\n"
"\n"
"	// Continue visiting nodes until the next nearest plane lies beyond max_t (in which case\n"
"	// there can be no more intersections possible).\n"
"	while (t0 < max_t)\n"
"	{\n"
"		// Pop from the stack.\n"
"		vec2  node = other_node;\n"
"		float t1 = other_t1;\n"
"		vec4 pln0 = other_pln0;\n"
"		\n"
"		// Reset the stack.\n"
"		other_node = vec2(0);\n"
"		other_t1 = max_t;\n"
"\n"
"		// Travel down the BSP.\n"
"		do\n"
"		{\n"
"			vec4 pln = texture(bsp_planes, node);\n"
"			vec4 children = texture(bsp_branches, node);\n"
"			\n"
"			// Perform ray-plane intersection and order the children according to traversal order.\n"
"			\n"
"			float t = dot(pln.xyz, dir);\n"
"\n"
"			children = (t > 0.0) ? children.zwxy : children.xyzw;\n"
"\n"
"			t = (pln.w - dot(pln.xyz, org)) / t;\n"
"\n"
"			if (t > t0)\n"
"			{\n"
"				// The near node is intersected.\n"
"				node = children.xy;\n"
"				\n"
"				if (t < t1) \n"
"				{\n"
"					// Both children need to be visited, so push the further children onto the stack.\n"
"					other_t1 = t1;\n"
"					t1 = t;\n"
"					other_pln0 = pln0;\n"
"					pln0 = pln;\n"
"					other_node = children.zw;\n"
"				}\n"
"			}\n"
"			else\n"
"			{\n"
"				// Only the far node is intersected.\n"
"				node = children.zw;\n"
"			}\n"
"			\n"
"			if (node.y == 1.0)\n"
"			{\n"
"				 return t0;\n"
"			}\n"
"			\n"
"		} while (node != vec2(0));\n"
"		\n"
"		// Store the plane of intersection and push the current ray traversal point just beyond it.\n"
"		out_pln = pln0;\n"
"		t0 = t1 + EPS;\n"
"	}\n"
"\n"
"	return MAXT;\n"
"}\n"
"\n"
"// Returns false if the given ray intersects a solid leaf in the BSP and the distance\n"
"// to the intersection along the ray is less than maxdist, otherwise returns true.\n"
"bool traceRayShadowBSP(vec3 org, vec3 dir, float t0, float max_t)\n"
"{\n"
"	return traceRayBSP(org, dir, t0, max_t) >= max_t;\n"
"}\n"
"\n"
"// Returns the light list head references for the given point. The X component points to the \n"
"// direct light list and the Y component points to the skyportal list.\n"
"ivec2 getLightRef(vec3 p)\n"
"{\n"
"	vec2 node = vec2(0), prev_node;\n"
"	float d;\n"
"	\n"
"	// Travel down the BSP.\n"
"	do\n"
"	{\n"
"		vec4 pln = texture(bsp_planes, node);\n"
"		vec4 children = texture(bsp_branches, node);\n"
"		\n"
"		d = dot(pln.xyz, p) - pln.w;\n"
"		\n"
"		if (d < 0.0)\n"
"		{\n"
"			prev_node = node;\n"
"			node = children.zw;\n"
"		}\n"
"		else\n"
"		{\n"
"			prev_node = node;\n"
"			node = children.xy;\n"
"		}\n"
"\n"
"		if (node.y == 1.0)\n"
"			 return ivec2(0);\n"
"		\n"
"	} while (node != vec2(0));\n"
"	\n"
"	ivec4 light_indices = texture(bsp_lightrefs, prev_node);\n"
"	\n"
"	return d < 0.0 ? light_indices.yw : light_indices.xz;\n"
"}\n"
"\n"
"vec3 sampleDirectLightForMirrorBRDF(vec3 rp, vec3 rd, vec3 rn, int oli)\n"
"{\n"
"	vec3 r = vec3(0);\n"
"	oli = oli < 0 ? -oli : +oli;\n"
"	int li = oli;\n"
"	int ref = texelFetch(lightrefs, li).r;\n"
"	\n"
"	if (ref != -1)\n"
"	{\n"
"		vec3 refl_dir = reflect(rd, rn);\n"
"		float max_t = traceRayBSP(rp, refl_dir, EPS * 16, MAXT);\n"
"\n"
"		do\n"
"		{\n"
"			vec4 light = texelFetch(lights, ref);\n"
"\n"
"			ivec2 tri = texelFetch(triangles, floatBitsToInt(light.w)).xy;\n"
"\n"
"			vec3 p0 = texelFetch(tri_vertices, tri.x & 0xffff).xyz;\n"
"			vec3 p1 = texelFetch(tri_vertices, tri.x >> 16).xyz;\n"
"			vec3 p2 = texelFetch(tri_vertices, tri.y & 0xffff).xyz;\n"
"\n"
"			vec3 n = normalize(cross(p1 - p0, p2 - p0));\n"
"\n"
"			float t = dot(p0 - rp, n) / dot(refl_dir, n);\n"
"			\n"
"			float d = dot(refl_dir, n);\n"
"			vec3 sp2 = rp + refl_dir * t;\n"
"			\n"
"			if (d > 0.0 && t > 0.0 && t < max_t && dot(p0 - sp2, n) < 0.1 && dot(p0 - sp2, n) > -1e-3)\n"
"			{	\n"
"				float s1 = dot(cross(p1 - sp2, p2 - sp2), n);\n"
"\n"
"				if (dot(light.rgb, vec3(1)) < 0.0 && s1 < 0.0)\n"
"				{\n"
"					s1 *= -1.0;\n"
"					vec3 mirror = normalize(p2 - p1);\n"
"					sp2 -= 2.0 * mirror * dot(sp2 - (p1 + p2) * 0.5, mirror);\n"
"					mirror = cross(mirror, n);\n"
"					sp2 -= 2.0 * mirror * dot(sp2 - p1, mirror);\n"
"				}\n"
"\n"
"				float s0 = dot(cross(p0 - sp2, p1 - sp2), n);\n"
"				float s2 = dot(cross(p2 - sp2, p0 - sp2), n);\n"
"\n"
"				if (s0 > 0.0 && s1 > 0.0 && s2 > 0.0 && traceRayShadowTri(rp, refl_dir, t, tri_nodes0, tri_nodes1, tri_vertices, triangles, shadow_ray_node_offset))\n"
"				{\n"
"					return abs(light.rgb);\n"
"				}\n"
"			}\n"
"\n"
"			++li;\n"
"			ref = texelFetch(lightrefs, li).r;\n"
"			\n"
"		} while (ref != -1);\n"
"	}\n"
"	\n"
"	return vec3(0);\n"
"}\n"
"\n"
"// Returns the amount of direct light incident at the given point with the given surface normal.\n"
"// oli is an index to the first lightsource reference.\n"
"vec3 sampleDirectLight(vec3 rp, vec3 rn, int oli)\n"
"{\n"
"#if NUM_LIGHT_SAMPLES == 0\n"
"	return vec3(0);\n"
"#else\n"
"	vec3 r = vec3(0);\n"
"	oli = oli < 0 ? -oli : +oli;\n"
"	int li = oli;\n"
"	int ref = texelFetch(lightrefs, li).r;\n"
"	\n"
"	if (ref != -1)\n"
"	{\n"
"		float wsum = 0.0;\n"
"		\n"
"		// Visit each referenced light and sum up the importance weights for the purpose of weight normalisation.\n"
"		do\n"
"		{\n"
"			vec4 light = texelFetch(lights, ref);\n"
"\n"
"			ivec2 tri = texelFetch(triangles, floatBitsToInt(light.w)).xy;\n"
"\n"
"			vec3 p0 = texelFetch(tri_vertices, tri.x & 0xffff).xyz;\n"
"			vec3 p1 = texelFetch(tri_vertices, tri.x >> 16).xyz;\n"
"			vec3 p2 = texelFetch(tri_vertices, tri.y & 0xffff).xyz;\n"
"\n"
"			vec3 n = cross(p2 - p0, p1 - p0);\n"
"\n"
"			// Calculate the importance weight.\n"
"			float d = distance(rp, (p0 + p1 + p2) / 3.0);\n"
"			float pd = dot(normalize(rp - (p0 + p1 + p2) / 3.0), n);\n"
"			float w = length(light.rgb) * max(0.0, pd) / (d * d);\n"
"\n"
"			wsum += w;\n"
"			++li;\n"
"			ref = texelFetch(lightrefs, li).r;\n"
"			\n"
"		} while (ref != -1);\n"
"		\n"
"		// Sample the set of lightsources using importance sampling.\n"
"		for (int light_sample = 0; light_sample < NUM_LIGHT_SAMPLES; ++light_sample)\n"
"		{\n"
"			li = oli;\n"
"			ref = texelFetch(lightrefs, li).r;\n"
"			\n"
"			vec3 p0, p1, p2, n;\n"
"\n"
"			// Choose a lightsource randomly, with each lightsource having a probability of being chosen\n"
"			// proportional to it's importance weight.\n"
"			\n"
"			float x = rand(light_sample).x * wsum, w=1.0;\n"
"			vec4 j = vec4(0);\n"
"\n"
"			do\n"
"			{\n"
"				vec4 light=texelFetch(lights, ref);\n"
"				ivec2 tri = texelFetch(triangles, floatBitsToInt(light.w)).xy;\n"
"				\n"
"				p0 = texelFetch(tri_vertices, tri.x & 0xffff).xyz;\n"
"				p1 = texelFetch(tri_vertices, tri.x >> 16).xyz;\n"
"				p2 = texelFetch(tri_vertices, tri.y & 0xffff).xyz;\n"
"				\n"
"				n = cross(p2 - p0, p1 - p0);\n"
"				\n"
"				// Calculate the importance weight.\n"
"				float d = distance(rp, (p0 + p1 + p2) / 3.0);\n"
"				float pd = dot(normalize(rp - (p0 + p1 + p2) / 3.0), n);\n"
"				\n"
"				w = length(light.rgb) * max(0.0, pd) / (d * d);\n"
"				\n"
"				x -= w;\n"
"				\n"
"				if (x < 0.0)\n"
"				{\n"
"					// This lightsource has been chosen.\n"
"					j = light;\n"
"					break;\n"
"				}\n"
"				\n"
"				++li;\n"
"				ref = texelFetch(lightrefs, li).r;\n"
"				\n"
"			} while (ref != -1);\n"
"\n"
"#if NUM_SHADOW_SAMPLES > 0\n"
"			// Trace shadow rays towards the lightsource to calculate a shadowing term.\n"
"			for (int shadow_sample = 0; shadow_sample < NUM_SHADOW_SAMPLES; ++shadow_sample)\n"
"			{\n"
"				vec3 sp = rp;\n"
"				vec3 sn = rn.xyz;\n"
"				vec3 lp = p0;\n"
"				vec2 uv = rand(shadow_sample);\n"
"				\n"
"				// Flip the barycentric coordinates if this is a triangle, don't if it's a parallelogram.\n"
"				if ((uv.x + uv.y) > 1.0 && dot(j.rgb, vec3(1)) > 0.0)\n"
"					uv = vec2(1) - uv;\n"
"				\n"
"				lp += (p1 - p0) * uv.x + (p2 - p0) * uv.y;\n"
"				\n"
"				float ld = distance(sp, lp);\n"
"				\n"
"				vec3 l = (lp - sp) / ld;\n"
"				float ndotl = dot(l, sn), lndotl = dot(-l, n);\n"
"				if (ndotl > 0.0 && lndotl > 0.0)\n"
"				{\n"
"					float s = (traceRayShadowBSP(sp, l, EPS * 16, ld) && traceRayShadowTri(sp, l, ld, tri_nodes0, tri_nodes1, tri_vertices, triangles, shadow_ray_node_offset)) ? 1.0 / (ld * ld) : 0.0;\n"
"					r += s * ndotl * lndotl * abs(j.rgb) * wsum / w;\n"
"				}\n"
"			}\n"
"#else\n"
"			r += abs(j.rgb) * wsum / w;\n"
"#endif\n"
"		}\n"
"	}\n"
"\n"
"	return r / float(NUM_LIGHT_SAMPLES * NUM_SHADOW_SAMPLES);\n"
"#endif\n"
"}\n"
"\n"
"float bumpHeightForDiffuseTexel(vec2 st)\n"
"{\n"
"	return dot(vec3(1.0 / 3.0), texture(diffuse_texture, st).rgb);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	bluenoise_sample = texture(bluenoise, vec3(gl_FragCoord.st / vec2(BLUENOISE_TEX_WIDTH, BLUENOISE_TEX_HEIGHT), rand_tex_layer)).rgb;\n"
"\n"
"	vec4 pln;\n"
"\n"
"	gl_FragColor = vec4(0);\n"
"\n"
"	// Get the ray origin point.\n"
"	vec3 rp = texcoords[1].xyz + texcoords[3].xyz * EPS * 16;\n"
"\n"
"	// Get the surface normal of the surface being rasterised.\n"
"	pln.xyz = normalize(texcoords[3].xyz);\n"
"	pln.w = dot(rp, pln.xyz);\n"
"\n"
"#if BUMP_ENABLE\n"
"	// Construct a shading normal for bump-mapping.\n"
"	vec2 bump_texel_size = vec2(1) / textureSize(diffuse_texture, 0).xy;\n"
"\n"
"	float bump_height0 = bumpHeightForDiffuseTexel(texcoords[0].st);\n"
"\n"
"	vec2 bump_gradients = vec2(bumpHeightForDiffuseTexel(texcoords[0].st + vec2(bump_texel_size.x, 0.0)) - bump_height0,\n"
"										bumpHeightForDiffuseTexel(texcoords[0].st + vec2(0.0, bump_texel_size.y)) - bump_height0) / bump_texel_size;\n"
"				\n"
"	vec3 shading_normal = normalize(pln.xyz - (texcoords[5].xyz * bump_gradients.x + texcoords[6].xyz * bump_gradients.y) * bump_factor);\n"
"#else\n"
"	vec3 shading_normal = normalize(pln.xyz);\n"
"#endif\n"
"\n"
"	float fresnel = texcoords[5].w * mix(0.9, 0.3, pow(clamp(1.0 - dot(shading_normal, -normalize(texcoords[7].xyz)), 0.0, 1.0), 4.0));\n"
"	bool brdf_mirror = fresnel < bluenoise_sample.b;\n"
"		\n"
"	// Sample the direct light at this point.\n"
"	int rpli = getLightRef(rp).x;\n"
"	vec3 r = brdf_mirror ? sampleDirectLightForMirrorBRDF(rp, normalize(texcoords[7].xyz), shading_normal, rpli) : sampleDirectLight(rp, shading_normal, rpli);\n"
"\n"
"	// Add the emissive light (light emitted towards the eye immediately from this surface).\n"
"	r += texcoords[4].rgb;\n"
"	\n"
"#if NUM_BOUNCES > 0 || NUM_AO_SAMPLES > 0 || NUM_SKY_SAMPLES > 0\n"
"	// Make an orthonormal basis for the primary ray intersection point.\n"
"	vec3 u = normalize(cross(pln.xyz, pln.zxy));\n"
"	vec3 v = cross(pln.xyz, u);\n"
"#endif\n"
"	\n"
"#if NUM_AO_SAMPLES > 0\n"
"	{\n"
"		// Apply importance-sampled (lambert diffuse BRDF) ambient occlusion.\n"
"		float ao = 0.0;\n"
"		for (int ao_sample = 0; ao_sample < NUM_AO_SAMPLES; ++ao_sample)\n"
"		{\n"
"			vec2 rr = rand(ao_sample);\n"
"			\n"
"			float r1 = 2.0 * PI * rr.x;\n"
"			float r2s = sqrt(rr.y);\n"
"\n"
"			// Lambert diffuse BRDF.\n"
"			vec3 rd = u * cos(r1) * r2s + v * sin(r1) * r2s + pln.xyz * sqrt(1.0 - rr.y);\n"
"				\n"
"			if (traceRayShadowBSP(rp, rd, EPS * 16, ao_radius) && traceRayShadowTri(rp, rd, ao_radius, tri_nodes0, tri_nodes1, tri_vertices, triangles, shadow_ray_node_offset))\n"
"				ao += 1.0;\n"
"		}\n"
"		gl_FragColor.rgb += ao_color * ao / float(NUM_AO_SAMPLES);\n"
"	}\n"
"#endif\n"
"\n"
"#if NUM_BOUNCES > 0 || NUM_SKY_SAMPLES > 0\n"
"\n"
"	vec3 sp, rd;\n"
"	float t;\n"
"	float factor = bounce_factor;\n"
"\n"
"#if NUM_BOUNCES == 0\n"
"	// If there are no secondary bounces and there are no visible skyportals then there is no\n"
"	// need to sample the BRDF and trace a ray with it.\n"
"	if (rpli < 0)\n"
"#endif\n"
"	{\n"
"		if (brdf_mirror)\n"
"		{\n"
"			// Specular reflection.\n"
"			rd = normalize(reflect(normalize(texcoords[7].xyz), shading_normal));\n"
"		}\n"
"		else\n"
"		{\n"
"			// Lambert diffuse BRDF.\n"
"			vec2 rr = rand(0);\n"
"			float r1 = 2.0 * PI * rr.x;\n"
"			float r2s = sqrt(rr.y);\n"
"			rd = normalize(u * cos(r1) * r2s + v * sin(r1) * r2s + pln.xyz * sqrt(1.0 - rr.y));\n"
"			factor = clamp(dot(rd, shading_normal) / dot(rd, pln.xyz), 0.1, 2.0);\n"
"		}\n"
"		\n"
"		// Trace a ray against the BSP. This intersection point is later used for secondary bounces and testing\n"
"		// for containment in skyportals polygons (skyportals aren't sampled directly).\n"
"		t = traceRayBSP(rp, rd, EPS * 16, MAXT) - 1.0;\n"
"\n"
"		if ((dot(out_pln.xyz, rp) - out_pln.w) < 0.0)\n"
"			out_pln *= -1.0;\n"
"		\n"
"		sp = rp + rd * max(0.0, t);\n"
"	}\n"
"	\n"
"#if NUM_BOUNCES > 0\n"
"	// Test for intersection with triangle meshes. This is done so bounce light can be shadowed\n"
"	// by triangle meshes. It is only done if the ray has travelled a significant distance during the bounce.\n"
"	if (t > 1e-4 && traceRayShadowTri(rp, rd, t, tri_nodes0, tri_nodes1, tri_vertices, triangles, shadow_ray_node_offset))\n"
"	{\n"
"		int li = getLightRef(sp).x;\n"
"		r += factor * sampleDirectLight(sp, out_pln.xyz, li);\n"
"	}\n"
"#endif\n"
"\n"
"#if NUM_SKY_SAMPLES > 0\n"
"	if (rpli < 0)\n"
"	{\n"
"		// The list of skyportals is non-empty, so trace rays by sampling the BRDF and test for containment\n"
"		// of the intersection points from those rays in skyportal polygons.\n"
"		vec3 sky_r = vec3(0);\n"
"		for (int sky_sample = 0; sky_sample < NUM_SKY_SAMPLES; ++sky_sample)\n"
"		{\n"
"			int li = getLightRef(sp).y;\n"
"			int ref = texelFetch(lightrefs, li).r;\n"
"			if (ref != -1)\n"
"			{\n"
"				// Test for intersection with any triangle meshes. This is done so triangle meshes can cast shadows from sky light.\n"
"				if (traceRayShadowTri(rp, rd, t, tri_nodes0, tri_nodes1, tri_vertices, triangles, shadow_ray_node_offset))\n"
"				{\n"
"					// Visit each skyportal in this cluster and test for containment.\n"
"					do\n"
"					{\n"
"						vec4 light = texelFetch(lights, ref);\n"
"						ivec2 tri = texelFetch(triangles, floatBitsToInt(light.w)).xy;\n"
"						\n"
"						vec3 p0 = texelFetch(tri_vertices, tri.x & 0xffff).xyz;\n"
"						vec3 p1 = texelFetch(tri_vertices, tri.x >> 16).xyz;\n"
"						vec3 p2 = texelFetch(tri_vertices, tri.y & 0xffff).xyz;\n"
"						\n"
"						vec3 n = normalize(cross(p1 - p0, p2 - p0));\n"
"						\n"
"						vec3 sp2 = sp;\n"
"						\n"
"						float s1 = dot(cross(p1 - sp2, p2 - sp2), n);\n"
"\n"
"						// If the skyportal is a parallelogram and the subtriangle opposing the reflected\n"
"						// vertex has negative area then reflect the sample point back into the triangle.\n"
"						if (dot(light.rgb, vec3(1)) < 0.0 && s1 < 0.0)\n"
"						{\n"
"							s1 *= -1.0;\n"
"							vec3 mirror = normalize(p2 - p1);\n"
"							sp2 -= 2.0 * mirror * dot(sp2 - (p1 + p2) * 0.5, mirror);\n"
"							mirror = cross(mirror, n);\n"
"							sp2 -= 2.0 * mirror * dot(sp2 - p1, mirror);\n"
"						}\n"
"\n"
"						float s0 = dot(cross(p0 - sp2, p1 - sp2), n);\n"
"						float s2 = dot(cross(p2 - sp2, p0 - sp2), n);\n"
"\n"
"						if (s0 > 0.0 && s1 > 0.0 && s2 > 0.0 && abs(dot(n, sp2 - p0)) < 1.0)\n"
"						{\n"
"							// The sample point is contained by this polygon, so add the light contribution.\n"
"							sky_r += abs(light.rgb) * clamp(dot(rd, shading_normal) / dot(rd, pln.xyz), 0.1, 2.0);\n"
"						}\n"
"						\n"
"						++li;\n"
"						ref = texelFetch(lightrefs, li).r;\n"
"						\n"
"					} while (ref != -1);\n"
"				}\n"
"			}\n"
"\n"
"#if NUM_SKY_SAMPLES > 1\n"
"			// There are further sky samples to be made, so sample the BRDF again to trace a new ray\n"
"			// out into the scene to create a new sample point.\n"
"			vec2 rr = rand(sky_sample + 1);\n"
"\n"
"			float r1 = 2.0 * PI * rr.x;\n"
"			float r2s = sqrt(rr.y);\n"
"\n"
"			// Lambert diffuse BRDF.\n"
"			rd = normalize(u * cos(r1) * r2s + v * sin(r1) * r2s + pln.xyz * sqrt(1.0 - rr.y));\n"
"\n"
"			t = traceRayBSP(rp, rd, EPS * 16, MAXT) - 1.0;\n"
"			\n"
"			sp = rp + rd * max(0.0, t);\n"
"#endif\n"
"		}\n"
"		r += sky_r / float(NUM_SKY_SAMPLES);\n"
"	}\n"
"#endif\n"
"\n"
"#if NUM_BOUNCES > 1\n"
"	{\n"
"		if ((dot(out_pln.xyz, rp) - out_pln.w) < 0.0)\n"
"			out_pln *= -1.0;\n"
"\n"
"		// Trace secondary rays to gather bounce light from surrounding surfaces. This does not include sky light.\n"
"		float factor = bounce_factor;\n"
"		rp = sp;\n"
"		for (int bounce = 1; bounce < NUM_BOUNCES; ++bounce)\n"
"		{\n"
"			vec2 rr = rand(bounce);\n"
"\n"
"			float r1 = 2.0 * PI * rr.x;\n"
"			float r2s = sqrt(rr.y);\n"
"\n"
"			// Lambert diffuse BRDF.\n"
"			vec3 rd = normalize(u * cos(r1) * r2s + v * sin(r1) * r2s + out_pln.xyz * sqrt(1.0 - rr.y));\n"
"\n"
"			t = traceRayBSP(rp, rd, EPS * 16, MAXT) - 1.0;\n"
"\n"
"			if (!traceRayShadowTri(rp, rd, t, tri_nodes0, tri_nodes1, tri_vertices, triangles, shadow_ray_node_offset))\n"
"				break;\n"
"			\n"
"			if ((dot(out_pln.xyz, rp) - out_pln.w) < 0.0)\n"
"				out_pln *= -1.0;\n"
"			\n"
"			rp = rp + rd * max(0.0, t);\n"
"			\n"
"			// Simulate (achromatic) absorption of light at the surface.\n"
"			factor *= bounce_factor;\n"
"			\n"
"			int li = getLightRef(rp).x;\n"
"			pln = out_pln;\n"
"			r += factor * sampleDirectLight(rp, out_pln.xyz, li);\n"
"			out_pln = pln;\n"
"			\n"
"#if NUM_BOUNCES > 2\n"
"			u = normalize(cross(out_pln.xyz, out_pln.zxy));\n"
"			v = cross(out_pln.xyz, u);\n"
"#endif\n"
"		}\n"
"	}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"	// Apply an arbitrary scaling to empirically match the output of qrad3.\n"
"	gl_FragColor.rgb += r / 1024.;\n"
"\n"
"	gl_FragColor.a = color.a;\n"
"	\n"
"#if DIFFUSE_MAP_ENABLE\n"
"	// Multiply the gathered light with the diffuse albedo.\n"
"	gl_FragColor.rgb *= texture(diffuse_texture, texcoords[0].st).rgb + vec3(1e-2);\n"
"#endif\n"
"\n"
"	// Tone mapping (Simple Reinhard).\n"
"	gl_FragColor.rgb *= exposure / (vec3(1) + gl_FragColor.rgb / exposure);\n"
"\n"
"	// Gamma.\n"
"	gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(1.0 / gamma));\n"
"	\n"
"#if TAA_ENABLE\n"
"	if (texcoords[4].w > 0.0)\n"
"	{\n"
"		// Apply TAA.\n"
"		\n"
"		vec4 clip = previous_world_matrix * texcoords[1];\n"
"		vec2 ndc = clip.xy / clip.w * 0.5 + vec2(0.5);\n"
"		\n"
"		rp = texcoords[1].xyz + texcoords[3].xyz * EPS * 16;\n"
"		\n"
"		// Check if the fragment was visible in the previous frame. If not, then the information in the previous framebuffer does not match and it cannot be reused.\n"
"      // Zero is passed as the node offset to traceRayShadowTri so that the viewmodel always participates in the disocclusion test. This is necessary to prevent ghosting on the viewmodel.\n"
"		vec3 disocclusion_test_ray = normalize(previous_view_origin - rp);\n"
"		float disocclusion_test_distance = distance(rp, previous_view_origin);\n"
"		bool previously_visible = traceRayShadowBSP(rp, disocclusion_test_ray, EPS * 16, disocclusion_test_distance) &&\n"
"				traceRayShadowTri(rp, disocclusion_test_ray, disocclusion_test_distance, tri_nodes0_prev, tri_nodes1_prev, tri_vertices_prev, triangles_prev, 0) &&\n"
"				dot(normalize(texcoords[3].xyz), disocclusion_test_ray) > 0.01;\n"
"		\n"
"		gl_FragColor.rgb = mix(gl_FragColor.rgb, texture(taa_world, ndc).rgb,\n"
"				all(greaterThan(ndc, vec2(0))) && all(lessThan(ndc, vec2(1))) && previously_visible ? 0.45 * texcoords[4].w : 0.0);\n"
"	}\n"
"#endif\n"
"}\n"
